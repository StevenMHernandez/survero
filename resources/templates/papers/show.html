{% extends 'base.html' %}

{% block css %}
<style>
    .sr-only {
        display: none;
    }
    ul#notes {
        margin-top:15px;
    }
    ul#notes li {
        margin-bottom: 15px;
        border-bottom: 1px solid #e0e0e0;
        padding-bottom: 15px;
    }
    .deletable {
        cursor: pointer;
    }
</style>
{% endblock %}

{% block title %}
{{ item.key }}
{% endblock %}

{% block content %}
{% raw %}

<div id="app" v-cloak>
    <div class="container">
        <div class="row">
            <h1>
                {{ item.title }}
            </h1>
            <h5>
                <span v-if="item.authors && item.authors.length == 0" class="text-warning">Warning: No Authors Found</span>
                <span v-for="a,i in item.authors">
                    <span v-if="i>0">,</span>
                    <a v-bind:href="'/workspaces/' + workspace.key + '/authors/' + a.creatorID">
                        {{a.firstName}} {{a.lastName}}
                    </a>
                </span>
            </h5>
            <h6 class="text-muted" v-for="c in item.collections">(Collection: {{ c.collectionName }})</h6>
            <div v-if="item.screenshots">
                <div v-for="row in Math.ceil(item.screenshots.length / 3)">
                    <b-container fluid class="p-4 bg-dark">
                        <b-row>
                            <b-col v-if="(row-1) * 3 + i - 1 < item.screenshots.length" v-for="i in 3" style="max-width: 400px;" class="text-center">
                                <b-img thumbnail fluid v-bind:src="'/uploads/' + item.screenshots[(row-1) * 3 + i - 1].file_name"></b-img>
                                <div>
                                    <small class="text-danger deletable" v-on:click="deleteScreenshot(item.screenshots[(row-1) * 3 + i - 1])">Delete</small>
                                </div>
                            </b-col>
                        </b-row>
                    </b-container>
                </div>
            </div>
            <ul>
                <li v-for="a in item.attachments">
                    <b-input-group v-bind:prepend="a.key" class="mt-3">
                        <b-form-input type="text" v-on:click="copy"
                                      v-bind:value="'open ' + (a.path.replace('storage:', ''))">
                        </b-form-input>
                    </b-input-group>
                </li>
            </ul>
            <hr>


            <b-col>
                <b-input-group prepend="Add a Tag" class="mt-3">

                    <typeahead
                            ref="typeahead"
                            v-model="new_tag_text"
                            v-bind:data="allTags"
                            v-bind:min-matching-chars="1"
                            v-bind:show-on-focus="true"
                            @hit="addTag"
                            @keyup.enter="addTag">
                    </typeahead>
                    <b-input-group-append>
                        <b-button v-on:click="addTag">Create</b-button>
                    </b-input-group-append>
                </b-input-group>
                <ul>
                    <li v-for="t in item.tags">
                        <span v-bind:class="tagTextColor(t.tag)">
                            {{ t.tag }}
                        </span>

                        <small class="text-danger deletable" v-on:click="deleteTag(t)">(X)</small>
                    </li>
                    <hr v-if="deletedTags.length > 0">
                    <li v-for="t in deletedTags" class="text-muted">
                        Deleted:
                        <del>{{ t }}</del>
                    </li>
                </ul>
            </b-col>

            <b-col>
                <b-input-group prepend="Add a Note" class="mt-3">

                    <input
                            class="form-control"
                            ref="typeahead"
                            v-model="new_note_text"
                            @keyup.enter="addNote"/>
                    <b-input-group-append>
                        <b-button v-on:click="addNote">Create</b-button>
                    </b-input-group-append>
                </b-input-group>
                <ul id="notes" v-if="item.notes && item.notes.length > 0">
                    <li v-for="n in item.notes.slice().reverse()">
                        <template v-for="v in splitNoteText(n.note)">
                            <a v-if="v['isPaperKey']" v-bind:href="'/papers/' +  v['value']">{{ v['value'] }}</a>
                            <span v-if="!v['isPaperKey']">{{ v['value'] }}</span>
                        </template>
                        <br>
                        <small>
                            <span class="text-success">{{ n.user.name }}</span>
                            : <em>{{ DateTime.fromISO(n.created_at).toLocaleString(DateTime.DATETIME_FULL) }}</em>
                            <em class="text-danger deletable" v-on:click="deleteNote(n)">Delete</em>
                        </small>
                    </li>
                </ul>
            </b-col>
        </div>
    </div>
    <vuefullscreenfiledrop @drop='addScreenshot'></vuefullscreenfiledrop>
</div>
{% endraw %}

{% endblock %}


{% block script %}
<script>
    var app = null;
    workspace = {{ workspace|tojson }}

    window.onload = () => {
        Vue.component('vuefullscreenfiledrop', VueFullScreenFileDrop);
        Vue.component('typeahead', VueTypeaheadBootstrap);
        app = new Vue({
            el: '#app',
            data() {
                return {
                    DateTime: window.DateTime,
                    workspace: workspace,
                    isBusy: false,
                    item: {},
                    ZOTERO_PATH: '{{ config("application.zotero_path") }}',
                    new_tag_text: this.getDefaultTagString(),
                    new_note_text: '',
                    allTags: [],
                    newlyAddedTags: [],
                    deletedTags: [],
                    previouslyAddedTag: "",
                }
            },
            methods: {
                reload() {
                    axios.get('/api/workspaces/' + workspace.key + '/papers/{{ item.key }}')
                        .then(response => {
                            this.item = response.data;
                            document.title = document.title.replace(this.item.key, '"' + this.item.title + '"')
                            this.item.tags = this.item.tags.sort((x,y) => {
                                return x.tag > y.tag
                            });

                            axios.get('/api/workspaces/' + workspace.key + '/tags/')
                                .then(response => {
                                    this.allTags = response.data.map(t => {
                                        return t.tag
                                    }).filter(t => {
                                        return !this.item.tags.map(x => x.tag).includes(t);
                                    });
                                });
                        });

                },
                addScreenshot(formData, files) {
                    formData.set('paper_key', '{{ item.key }}');
                    formData.set('__token', '{{ csrf_token }}');
                    axios({
                        method: "post",
                        url: '/api/screenshots',
                        data: formData,
                        headers: {"Content-Type": "multipart/form-data"},
                    }).then(response => {
                        this.reload();
                    });
                },
                addTag() {
                    if (
                        this.new_tag_text !== ''
                        && this.new_tag_text !== this.getDefaultTagString()
                        && this.newlyAddedTags.indexOf(this.new_tag_text) === -1
                    ) {
                        this.newlyAddedTags.push(this.new_tag_text);
                        axios({
                            method: "post",
                            url: '/api/tags',
                            data: {
                                '__token': '{{ csrf_token }}',
                                'paper_key': '{{ item.key }}',
                                'tag': this.new_tag_text,
                            },
                        }).then(response => {
                            this.reload();
                            this.previouslyAddedTag = this.new_tag_text;
                            this.new_tag_text = this.getDefaultTagString();
                            this.$refs.typeahead.$refs.input.focus();
                        });
                    }
                },
                deleteTag(tag) {
                    this.deletedTags.push(tag.tag);
                    this.newlyAddedTags = this.newlyAddedTags.filter(t => t !== tag.tag);
                    axios({
                        method: "delete",
                        url: '/api/tags/' + tag.id,
                        data: {
                            '__token': '{{ csrf_token }}',
                        },
                    }).then(response => {
                        this.reload();
                    });
                },
                deleteNote(note) {
                    axios({
                        method: "delete",
                        url: '/api/notes/' + note.id,
                        data: {
                            '__token': '{{ csrf_token }}',
                        },
                    }).then(response => {
                        this.reload();
                    });
                },
                deleteScreenshot(screenshot) {
                    axios({
                        method: "delete",
                        url: '/api/screenshots/' + screenshot.id,
                        data: {
                            '__token': '{{ csrf_token }}',
                        },
                    }).then(response => {
                        this.reload();
                    });
                },
                addNote() {
                    if (this.new_note_text !== '') {
                        axios({
                            method: "post",
                            url: '/api/notes',
                            data: {
                                '__token': '{{ csrf_token }}',
                                'paper_key': '{{ item.key }}',
                                'note': this.new_note_text,
                            },
                        }).then(response => {
                            this.reload();
                            this.new_note_text = '';
                        });
                    }
                },
                copy(e, i) {
                    console.log(e, i);
                    e.target.select();
                    document.execCommand("copy");
                },
                tagTextColor(t) {
                    if (this.newlyAddedTags.indexOf(t) > -1) {
                        return 'text-success';
                    }

                    tag_group = new URL(location.href).searchParams.get('tag_group');
                    if (tag_group && t.indexOf(tag_group) === 0) {
                        return 'text-info';
                    }

                    return ''
                },
                getDefaultTagString() {
                    tag_group = new URL(location.href).searchParams.get('tag_group');
                    if (tag_group) {
                        return tag_group + ": ";
                    }

                    if (this.previouslyAddedTag && this.previouslyAddedTag.indexOf(":") > -1) {
                        return this.previouslyAddedTag.substring(0, this.previouslyAddedTag.lastIndexOf(":")) + ": ";
                    }

                    return "";
                },
                splitNoteText(text) {
                    var reg = /([A-Z0-9]{8})[ \.]/g;
                    var ignore_list = [
                        'LABELLED',
                        'TERRIBLE',
                        'MPORTANT',
                    ];
                    return text.split(reg).map(x => {
                        console.log(x.match(reg));
                        return {
                            'value': x,
                            'isPaperKey': !!x.match(reg) && ignore_list.indexOf(x.match(reg)[0]) < 0,
                        }
                    })
                }
            },
            mounted() {
                this.reload()
            },
            created() {
                self = this;

                document.addEventListener('visibilitychange', function() {
                    if (!document.hidden) {
                        self.reload()
                    }
                }, false);

                window.addEventListener('paste', e => {
                    for (let i = 0; i < e.clipboardData.files.length; i++) {
                        var formData = new FormData();
                        formData.append('upload', e.clipboardData.files[i], e.clipboardData.files[i].name)
                        self.addScreenshot(formData, e.clipboardData.files)
                    }
                });
            }
        })
    }
</script>
{% endblock %}
